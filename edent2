#!/usr/bin/env escript
%% -*- erlang -*-
%%! -sname edent debug verbose

main([Input, Output | _ ]) ->
    {ok, Data} = file:read_file(Input),
    {ok, Tokens, _} = erl_scan:string(binary_to_list(Data), 0, [return]),
    ok = file:write_file(Output, process(Tokens)),
    halt(0);
main(_) ->
    io:fwrite(standard_error, "usage: edent <input> <output>~n", []),
    halt(1).


-record(state, {
    indent = 0 :: pos_integer(),
    in_case = false :: boolean(),
    in_when = false :: boolean()
}).


process(Tokens) ->
    process(Tokens, [], #state{}).

process([], Output, _) ->
    lists:reverse(Output);
process(Tokens, Output, State) ->
    erlang:display('------------------------'),
    {Line, Rest} = next_line(Tokens),
    erlang:display({line, State, Line}),
    {LineFmt, StateFmt} = format_line(Line, State),
    erlang:display({fmt, StateFmt, LineFmt}),
    io:format(iolist_to_binary(LineFmt)),
    process(Rest, [LineFmt | Output], StateFmt).


next_line(Tokens) ->
    next_line(Tokens, []).

next_line([{white_space, _, Text} | Rest], Acc) ->
    case lists:splitwith(fun (C) -> C /= $\n end, Text) of
        {_, []} -> next_line(Rest, [{white_space, Text} | Acc]);
        {_, [$\n | Tail]} -> {lists:reverse(Acc), [{white_space, 0, Tail} | Rest]}
    end;
next_line([] = Rest, Acc) ->
    {lists:reverse(Acc), Rest};
next_line([{Cat, _, Value} | Rest], Acc) ->
    next_line(Rest, [{Cat, Value} | Acc]);
next_line([{Cat, _} | Rest], Acc) ->
    next_line(Rest, [Cat | Acc]).


format_line(Line, #state{ indent = Indent } = State) ->
    case lists:reverse(trim(lists:reverse(trim(Line)))) of
        [] ->
            {[$\n], State};
        Trimmed ->
            LineIndent = Indent + count_head(Trimmed, State),
            format_line(Trimmed, [lists:duplicate(LineIndent * 4, $\s)], State)
    end.

format_line([], Output, State) ->
    {lists:reverse([$\n | Output]), State};
format_line([Token | Rest], Output, State) ->
    erlang:display({token, Token, state(Token, State)}),
    format_line(Rest, [token_to_list(Token) | Output], state(Token, State)).


%% erl_scan is really fucking stupid and instead of keeping the
%% original [$\\, $\n] it decides to replace it by $\n at which point
%% it's impossible to tell what the original was and we just have to
%% make a wild guess instead.
escape($\e) -> [$\\, $e];
escape($\f) -> [$\\, $f];
escape($\n) -> [$\\, $n];
escape($\r) -> [$\\, $n];
escape($\v) -> [$\\, $v];
escape(C) -> C.

escape([], Acc) -> lists:reverse(Acc);
escape([C | Rest], Acc) -> escape(Rest, [escape(C) | Acc]).

token_to_list({_, Atom}) when is_atom(Atom) ->
    atom_to_list(Atom);
token_to_list({string, Value}) ->
    [$\", escape(Value, []), $\"];
token_to_list({integer, Value}) ->
    integer_to_binary(Value);
token_to_list({float, Value}) ->
    float_to_binary(Value);
token_to_list({_, Text}) ->
    Text;
token_to_list(dot) ->
    $.;
token_to_list(Atom) when is_atom(Atom)->
    atom_to_list(Atom).


trim([]) ->
    [];
trim([{white_space, _} | Rest]) ->
    trim(Rest);
trim(Tokens) ->
    Tokens.


count_head(Tokens, State) ->
    count_head(Tokens, 0, State).

count_head([], Count, _) ->
    Count;
count_head(['of' | Rest], Count, #state{ in_case = true } = State) ->
    count_head(Rest, Count - 1, State);
count_head(['->' | Rest], Count, #state{ in_when = true } = State) ->
    count_head(Rest, Count - 1, State);
count_head([Token | Rest], Count, State) ->
    case indent(Token) of
        -1 -> count_head(Rest, Count - 1, State);
        _ -> Count
    end.


indent('(') -> +1;
indent(')') -> -1;
indent('[') -> +1;
indent(']') -> -1;
indent('#{') -> +1;
indent('{') -> +1;
indent('}') -> -1;
indent(';') -> -1;
indent('.') -> -1;
indent('->') -> +1;
indent('<<') -> +1;
indent('>>') -> -1;
indent('end') -> -1;
indent('of') -> +1;
indent('case') -> +1;
indent('when') -> +1;
indent(_) -> 0.


state('case', #state{ indent = Indent } = State) ->
    State#state{ indent = Indent + 1, in_case = true };

state('of', #state{ in_case = true } = State) ->
    State#state{ in_case = false };

state('when', #state{ indent = Indent } = State) ->
    State#state{ indent = Indent + 1, in_when = true };

state('->', #state{ in_when = true } = State) ->
    State#state{ in_when = false };

state(Token, #state{ indent = Indent } = State) ->
    State#state{ indent = Indent + indent(Token) }.
