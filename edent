#!/usr/bin/env escript
%% -*- erlang -*-
%%! -sname edent debug verbose

main([Input, Output | _ ]) ->
    {ok, Data} = file:read_file(Input),
    {ok, Tokens, _} = erl_scan:string(binary_to_list(Data), 0, [return]),
    ok = file:write_file(Output, process(Tokens)),
    halt(0);
main(_) ->
    io:fwrite(standard_error, "usage: edent <input> <output>~n", []),
    halt(1).


-record(state, {
    indent = 0 :: pos_integer(),
    stack = [] :: list(atom())
}).


process(Tokens) ->
    process(Tokens, [], #state{}).

process([], Output, _) ->
    lists:reverse(Output);
process(Tokens, Output, State) ->
    erlang:display('------------------------'),
    {Line, Rest} = next_line(Tokens),
    erlang:display({line, State, Line}),
    {LineFmt, StateFmt} = format_line(Line, State),
    erlang:display({fmt, StateFmt, LineFmt}),
    io:format(iolist_to_binary(LineFmt)),
    process(Rest, [LineFmt | Output], StateFmt).



next_line(Tokens) ->
    next_line(Tokens, []).

%% The erl_scan eats a \n character if it follows a dot character BUT
%% not if if there's a space or basically anything in between the two
%% characters. This is basically impossible to compensate for at this
%% point so I won't even bother. Clean up your trailing spaces folks...
next_line([{dot, _} | Rest], Acc) ->
    {lists:reverse([dot | Acc]), Rest};
next_line([{white_space, _, Text} | Rest], Acc) ->
    case lists:splitwith(fun (C) -> C /= $\n end, Text) of
        {_, []} -> next_line(Rest, [{white_space, Text} | Acc]);
        {_, [$\n | Tail]} -> {lists:reverse(Acc), [{white_space, 0, Tail} | Rest]}
    end;
next_line([], Acc) ->
    {lists:reverse(Acc), []};
next_line([{Cat, _, Value} | Rest], Acc) ->
    next_line(Rest, [{Cat, Value} | Acc]);
next_line([{Cat, _} | Rest], Acc) ->
    next_line(Rest, [Cat | Acc]).


format_line(Line, State) ->
    case lists:reverse(trim(lists:reverse(trim(Line)))) of
        [] ->
            {[$\n], State};
        Trimmed ->
            LineIndent = line_indent(Trimmed, State),
            format_line(Trimmed, [lists:duplicate(LineIndent * 4, $\s)], State)
    end.

format_line([], Output, State) ->
    {lists:reverse([$\n | Output]), State};
format_line([Token | Rest], Output, State) ->
    erlang:display({token, Token, state(Token, State)}),
    format_line(Rest, [token_to_list(Token) | Output], state(Token, State)).


%% erl_scan is really fucking stupid and instead of keeping the
%% original [$\\, $\n] it decides to replace it by $\n at which point
%% it's impossible to tell what the original was and we just have to
%% make a wild guess instead.
%%
%% TODO: Is this even necessary? You should be using ~n syntax for
%% formats anyway.
escape($\e) -> [$\\, $e];
escape($\f) -> [$\\, $f];
escape($\n) -> [$\\, $n];
escape($\r) -> [$\\, $n];
escape($\v) -> [$\\, $v];
escape(C) -> C.

escape([], Acc) -> lists:reverse(Acc);
escape([C | Rest], Acc) -> escape(Rest, [escape(C) | Acc]).


is_safe_atom([C | _]) when C < $a orelse C > $z ->
    false;
is_safe_atom(List) ->
    lists:all(fun (C) when C >= $a andalso C =< $z -> true;
                  (C) when C >= $A andalso C =< $A -> true;
                  (C) when C =:= $_ orelse C =:= $@ -> true;
                  (_) -> false end, List).

quoted_atom_to_list(Atom) ->
    List = atom_to_list(Atom),
    case is_safe_atom(List) of
        true -> List;
        false -> [$', List, $']
    end.


token_to_list({char, Char}) -> [$$, Char];
token_to_list({atom, Atom}) -> quoted_atom_to_list(Atom);
token_to_list({string, Value}) -> [$\", escape(Value, []), $\"];
token_to_list({integer, Value}) -> integer_to_binary(Value);
token_to_list({float, Value}) -> float_to_binary(Value);
token_to_list({_, Atom}) when is_atom(Atom) -> atom_to_list(Atom);
token_to_list({_, Text}) -> Text;
token_to_list(dot) -> $.;
token_to_list(receive_nomatch) -> "receive";
token_to_list(Atom) when is_atom(Atom) -> atom_to_list(Atom).


trim([]) ->
    [];
trim([{white_space, _} | Rest]) ->
    trim(Rest);
trim(Tokens) ->
    Tokens.


indent('(') -> +1;
indent(')') -> -1;
indent('[') -> +1;
indent(']') -> -1;
indent('#{') -> +1;
indent('{') -> +1;
indent('}') -> -1;
indent(';') -> -1;
indent('<<') -> +1;
indent('>>') -> -1;
indent('->') -> +1;
indent(dot) -> -1;
indent(_) -> 0.


line_indent(Tokens, #state{ indent = Indent} = State) ->
    max(0, line_indent(Tokens, Indent, State)).

line_indent([], Count, _) ->
    Count;

line_indent(['of' | Rest], _, #state{ stack = [{block, Indent, 'case'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['of' | Rest], _, #state{ stack = [{block, Indent, 'try'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['of' | _], _, State) ->
    throw({unmatched_of, State});

line_indent(['after' | Rest], _, #state{ stack = [{block, Indent, 'receive'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['after' | Rest], _, #state{ stack = [{block, Indent, 'try'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['after' | _], _, State) ->
    throw({unmatched_after, State});

line_indent(['end' | Rest], _, #state{ stack = [{block, Indent, _} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['end' | _], _, State) ->
    throw({unmatched_end, State});

line_indent(['catch' | Rest], _, #state{ stack = [{block, Indent, 'try'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });

line_indent(['->' | Rest], _, #state{ stack = [{block, Indent, 'when'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });

line_indent([Token | Rest], Indent, State) ->
    case indent(Token) of
        -1 -> line_indent(Rest, Indent - 1, State);
        _ -> Indent
    end.


%% Macros just kinda ignore all the regular syntax stuff so... fuck
%% me  I guess...
state('-', #state{ indent = 0, stack = Stack } = State) ->
    State#state{ stack = [macro | Stack] };

state('if' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('fun' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('try' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('case' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('begin' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('when' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('receive' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };

state('of', #state{ stack = [{block, Indent, 'case'} | _]} = State) ->
    State#state{ indent = Indent + 1};
state('of', #state{ stack = [{block, Indent, 'try'} | _]} = State) ->
    State#state{ indent = Indent + 1};
state('of', State) ->
    throw({unmatched_of, State});

state('after', #state{ stack = [{block, Indent, 'receive'} | _] } = State) ->
    State#state{ indent = Indent + 1 };
state('after', #state{ stack = [{block, Indent, 'try'} | _] } = State) ->
    State#state{ indent = Indent + 1 };
state('after', State) ->
    throw({unmatched_after, State});

state('catch', #state{ stack = [{block, Indent, 'try'} | _] } = State) ->
    State#state{ indent = Indent + 1 };
state('catch', State) ->
    State;

state('end', #state{ stack = [{block, Indent, _} | Stack] } = State) ->
    State#state{ indent = Indent, stack = Stack };
state('end', State) ->
    throw({unmatched_end, State});

state(dot, #state{ indent = 0, stack = [macro | Stack] } = State) ->
    State#state{ stack = Stack };
state(dot, #state{ indent = Indent, stack = [macro | Stack] } = State) ->
    State#state{ indent = Indent - 1, stack = Stack };

state('->', #state{ stack = [{block, Indent, 'when'} | Stack] } = State) ->
    State#state{ indent = Indent + 1, stack = Stack };

state(Token, #state{ indent = Indent } = State) ->
    State#state{ indent = Indent + indent(Token) }.
