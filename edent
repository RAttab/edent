#!/usr/bin/env escript
%% -*- erlang -*-
%%! -sname edent debug verbose

main([Input, Output | _ ]) ->
    {ok, Data} = file:read_file(Input),
    {ok, Tokens, _} = erl_scan:string(binary_to_list(Data), 0, [return]),
    ok = file:write_file(Output, process(Tokens)),
    halt(0);
main(_) ->
    io:fwrite(standard_error, "usage: edent <input> <output>~n", []),
    halt(1).


-record(state, {
        indent = 0 :: pos_integer(),
        stack = [] :: list(atom())
}).


process(Tokens) ->
    process(Tokens, [], #state{}).

process([], Output, _) ->
    lists:reverse(Output);
process(Tokens, Output, State) ->
    erlang:display('------------------------'),
    {Line, Rest} = next_line(Tokens),
    erlang:display({line, State, Line}),
    {LineFmt, StateFmt} = format_line(Line, State),
    erlang:display({fmt, StateFmt, LineFmt}),
    io:format(iolist_to_binary(LineFmt)),
    process(Rest, [LineFmt | Output], StateFmt).



next_line(Tokens) ->
    next_line(Tokens, []).

%% The erl_scan eats a \n character if it follows a dot character BUT
%% not if if there's a space or basically anything in between the two
%% characters. This is basically impossible to compensate for at this
%% point so I won't even bother. Clean up your trailing spaces folks...
next_line([{dot, _} | Rest], Acc) ->
    {lists:reverse([dot | Acc]), Rest};
next_line([{white_space, _, Text} | Rest], Acc) ->
    case lists:splitwith(fun (C) -> C /= $\n end, Text) of
        {_, []} -> next_line(Rest, [{white_space, Text} | Acc]);
        {_, [$\n | Tail]} -> {lists:reverse(Acc), [{white_space, 0, Tail} | Rest]}
    end;
next_line([], Acc) ->
    {lists:reverse(Acc), []};
next_line([{Cat, _, Value} | Rest], Acc) ->
    next_line(Rest, [{Cat, Value} | Acc]);
next_line([{Cat, _} | Rest], Acc) ->
    next_line(Rest, [Cat | Acc]).


format_line(Line, State) ->
    case lists:reverse(trim(lists:reverse(trim(Line)))) of
        [] ->
            {[$\n], State};
        Trimmed ->
            LineIndent = line_indent(Trimmed, State),
            format_line(Trimmed, [lists:duplicate(LineIndent * 4, $\s)], State)
    end.

format_line([], Output, State) ->
    {lists:reverse([$\n | Output]), State};
format_line([Token | Rest], Output, State) ->
    erlang:display({token, Token, state(Token, State)}),
    format_line(Rest, [token_to_list(Token) | Output], state(Token, State)).


%% erl_scan just removes all escape sequence so we can't rebuild the
%% original. To make things even more fun, there's different
%% expectations between literals and strings so... fuck me I guess...?
%%
%% TODO: Missing octal/hex escaping

escape_char($\b) -> [$\\, $b];
escape_char($\d) -> [$\\, $d];
escape_char($\e) -> [$\\, $e];
escape_char($\f) -> [$\\, $f];
escape_char($\n) -> [$\\, $n];
escape_char($\r) -> [$\\, $r];
escape_char($\s) -> [$\\, $s];
escape_char($\t) -> [$\\, $t];
escape_char($\v) -> [$\\, $v];
escape_char($\\) -> [$\\, $\\];
escape_char(C) when C >= 1 andalso C =< 26 -> [$\\, $^, ($A + C - 1)];
escape_char(C) -> C.

escape_str($") -> [$\\, $"];
escape_str($\b) -> [$\\, $b];
escape_str($\d) -> [$\\, $d];
escape_str($\e) -> [$\\, $e];
escape_str($\f) -> [$\\, $f];
escape_str($\n) -> [$\\, $n];
escape_str($\r) -> [$\\, $r];
escape_str($\t) -> [$\\, $t];
escape_str($\v) -> [$\\, $v];
escape_str($\\) -> [$\\, $\\];
escape_str(C) when C >= 1 andalso C =< 26 -> [$\\, $^, ($A + C - 1)];
escape_str(C) -> C.

escape_str([], Acc) -> lists:reverse(Acc);
escape_str([C | Rest], Acc) -> escape_str(Rest, [escape_str(C) | Acc]).


is_safe_atom('if', _) -> false;
is_safe_atom('of', _) -> false;
is_safe_atom('end', _) -> false;
is_safe_atom('fun', _) -> false;
is_safe_atom('try', _) -> false;
is_safe_atom('case', _) -> false;
is_safe_atom('when', _) -> false;
is_safe_atom('after', _) -> false;
is_safe_atom('begin', _) -> false;
is_safe_atom('catch', _) -> false;
is_safe_atom('receive', _) -> false;
is_safe_atom(_, [C | _]) when C < $a orelse C > $z -> false;
is_safe_atom(_, List) ->
    lists:all(fun
            (C) when C >= $a andalso C =< $z -> true;
            (C) when C >= $A andalso C =< $A -> true;
            (C) when C =:= $_ orelse C =:= $@ -> true;
            (_) -> false
        end, List).

quoted_atom_to_list(Atom) ->
    List = atom_to_list(Atom),
    case is_safe_atom(Atom, List) of
        true -> List;
        false -> [$', List, $']
    end.


token_to_list({char, Char}) -> [$$, escape_char(Char)];
token_to_list({atom, Atom}) -> quoted_atom_to_list(Atom);
token_to_list({string, Value}) -> [$", escape_str(Value, []), $"];
token_to_list({integer, Value}) -> integer_to_binary(Value);
token_to_list({float, Value}) -> float_to_binary(Value);
token_to_list({_, Atom}) when is_atom(Atom) -> atom_to_list(Atom);
token_to_list({_, Text}) -> Text;
token_to_list(dot) -> $.;
token_to_list(Atom) when is_atom(Atom) -> atom_to_list(Atom).


trim([]) ->
    [];
trim([{white_space, _} | Rest]) ->
    trim(Rest);
trim(Tokens) ->
    Tokens.


indent('(') -> +1;
indent(')') -> -1;
indent('[') -> +1;
indent(']') -> -1;
indent('#{') -> +1;
indent('{') -> +1;
indent('}') -> -1;
indent(';') -> -1;
indent('<<') -> +1;
indent('>>') -> -1;
indent('->') -> +1;
indent(dot) -> -1;
indent(_) -> 0.


line_indent(Tokens, #state{ indent = Indent} = State) ->
    Result = max(0, line_indent(Tokens, Indent, State)),
    erlang:display({line_indent, Result, State}),
    Result.

line_indent([], Count, _) ->
    Count;

line_indent(['of' | Rest], _, #state{ stack = [{block, Indent, 'case'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['of' | Rest], _, #state{ stack = [{block, Indent, 'try'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['of' | _], _, State) ->
    throw({unmatched_of, State});

line_indent(['after' | Rest], _, #state{ stack = [{block, Indent, 'receive'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['after' | Rest], _, #state{ stack = [{block, Indent, 'try'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['after' | _], _, State) ->
    throw({unmatched_after, State});

line_indent(['end' | Rest], _, #state{ stack = [{block, Indent, _} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });
line_indent(['end' | _], _, State) ->
    throw({unmatched_end, State});

line_indent(['catch' | Rest], _, #state{ stack = [{block, Indent, 'try'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });

line_indent(['->' | Rest], _, #state{ stack = [{block, Indent, 'when'} | Stack] } = State) ->
    line_indent(Rest, Indent, State#state{ stack = Stack });

% Behaves differently then regular closing indent.
line_indent([';' | Rest], Indent, State) ->
    line_indent(Rest, Indent, State);
line_indent([dot | Rest], Indent, State) ->
    line_indent(Rest, Indent, State);

line_indent([Token | Rest], Indent, State) ->
    case indent(Token) of
        -1 -> line_indent(Rest, Indent - 1, State);
        _ -> Indent
    end.


%% Macros just kinda ignore all the regular syntax stuff so... fuck
%% me  I guess...
state('-', #state{ indent = 0, stack = Stack } = State) ->
    State#state{ stack = [macro | Stack] };

state('if' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('fun' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('try' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('case' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('begin' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('when' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };
state('receive' = Token, #state{ indent = Indent, stack = Stack } = State) ->
    State#state{ indent = Indent + 1, stack = [{block, Indent, Token} | Stack] };

state('of', #state{ stack = [{block, Indent, 'case'} | _]} = State) ->
    State#state{ indent = Indent + 1};
state('of', #state{ stack = [{block, Indent, 'try'} | _]} = State) ->
    State#state{ indent = Indent + 1};
state('of', State) ->
    throw({unmatched_of, State});

state('after', #state{ stack = [{block, Indent, 'receive'} | _] } = State) ->
    State#state{ indent = Indent + 1 };
state('after', #state{ stack = [{block, Indent, 'try'} | _] } = State) ->
    State#state{ indent = Indent + 1 };
state('after', State) ->
    throw({unmatched_after, State});

state('catch', #state{ stack = [{block, Indent, 'try'} | _] } = State) ->
    State#state{ indent = Indent + 1 };
state('catch', State) ->
    State;

state('end', #state{ stack = [{block, Indent, _} | Stack] } = State) ->
    State#state{ indent = Indent, stack = Stack };
state('end', State) ->
    throw({unmatched_end, State});

state(dot, #state{ indent = 0, stack = [macro | Stack] } = State) ->
    State#state{ stack = Stack };
state(dot, #state{ indent = Indent, stack = [macro | Stack] } = State) ->
    State#state{ indent = Indent - 1, stack = Stack };

state('->', #state{ stack = [{block, Indent, 'when'} | Stack] } = State) ->
    State#state{ indent = Indent + 1, stack = Stack };

state(Token, #state{ indent = Indent } = State) ->
    State#state{ indent = Indent + indent(Token) }.
